const mapCfg = {
  hosts: {
    "okemby.798777.xyz": "https://link01.okemby.org:8443",
    "emby.798777.xyz":   "https://link01.okemby.org:8443",
    "emby1.798777.xyz":  "https://link01.okemby.org:8443",
    "emby2.798777.xyz":  "https://emos.best:443"
  },
  main: "https://link01.okemby.org:8443",
  cors: true
};

// ===== EMOS èº«ä»½ï¼ˆå¿…é¡»æ˜¯ä½ è‡ªå·±çš„ï¼‰=====
const EMOS_ID   = 'eG3X6K49Ys';
const EMOS_NAME = '@haotian';

// ===== ç¼“å­˜é…ç½® =====
const IMAGE_TTL = 86400; // 1 å¤©
const PING_TTL  = 60;    // 60 ç§’

export default {
  async fetch(req, env, ctx) {

    /* ===== CORS é¢„æ£€ ===== */
    if (req.method === 'OPTIONS') {
      return new Response(null, {
        status: 204,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, PATCH, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': '*',
          'Access-Control-Max-Age': '86400'
        }
      });
    }

    const rawUrl = new URL(req.url);
    const host   = rawUrl.hostname;

    /* ===== Host åˆ†æµ ===== */
    const target = mapCfg.hosts[host] || mapCfg.main;
    const isEmos = host === 'emby2.798777.xyz';

    const tUrl     = new URL(target);
    const finalUrl = new URL(rawUrl.pathname + rawUrl.search, tUrl);

    /* ===== è¯·æ±‚ç±»å‹è¯†åˆ« ===== */

    // ğŸ¯ è§†é¢‘æµï¼ˆTV å¿…é¡»å®Œå…¨ç»•å¼€ Worker å†…å­˜ï¼‰
    const isVideo =
      rawUrl.pathname.startsWith('/emby/Videos/') ||
      rawUrl.pathname.startsWith('/emby/Audio/') ||
      req.headers.has('Range');

    // å›¾ç‰‡ï¼ˆä»… EMOSï¼‰
    const isImage =
      isEmos &&
      req.method === 'GET' &&
      rawUrl.pathname.startsWith('/emby/Items/') &&
      rawUrl.pathname.includes('/Images/') &&
      !req.headers.has('Range');

    // Ping
    const isPing =
      isEmos &&
      req.method === 'GET' &&
      rawUrl.pathname === '/emby/System/Ping';

    /* ===== æ„é€ è¯·æ±‚å¤´ ===== */
    const h = new Headers(req.headers);

    // Host
    h.set('Host', tUrl.host);

    // Origin / Refererï¼ˆEMOS å›¾ç‰‡ä¸è£‚çš„å…³é”®ï¼‰
    const origin = `${tUrl.protocol}//${tUrl.hostname}`;
    h.set('Origin', origin);
    h.set('Referer', origin);

    /* ===== EMOS å¿…é¡»å¤´ ===== */
    if (isEmos) {
      h.set('EMOS-PROXY-ID', EMOS_ID);
      h.set('EMOS-PROXY-NAME', EMOS_NAME);

      const cfip = req.headers.get('CF-Connecting-IP');
      const xff  = req.headers.get('X-Forwarded-For');
      if (cfip) {
        h.set('X-Forwarded-For', xff ? `${xff}, ${cfip}` : cfip);
      }
    }

    /* ===== å›¾ç‰‡ç¦æ­¢ 304 ===== */
    if (isImage) {
      h.delete('If-None-Match');
      h.delete('If-Modified-Since');
    }

    /* ======================================================
       ğŸ¯ è§†é¢‘æµï¼šç›´æ¥é€ä¼ ï¼ˆTV ä¸æ–­æµæ ¸å¿ƒï¼‰
       ====================================================== */
    if (isVideo) {
      return fetch(new Request(finalUrl.toString(), {
        method: req.method,
        headers: h,
        body: req.body,
        redirect: 'manual', // â—å…³é”®ï¼šç¦æ­¢ follow
        duplex: 'half'
      }));
    }

    /* ===== Worker Cacheï¼ˆä»…å›¾ç‰‡ / Pingï¼‰===== */
    const cache = caches.default;
    const cacheKey = isImage
      ? `${tUrl.origin}${rawUrl.pathname}` // å›¾ç‰‡å» query
      : finalUrl.toString();

    if (isImage || isPing) {
      const cached = await cache.match(cacheKey);
      if (cached) return cached;
    }

    /* ===== æ™®é€šè¯·æ±‚ ===== */
    const newReq = new Request(finalUrl.toString(), {
      method: req.method,
      headers: h,
      body: req.body,
      redirect: 'manual',
      duplex: 'half'
    });

    try {
      const res  = await fetch(newReq);
      const resH = new Headers(res.headers);

      /* ===== CORS ===== */
      if (mapCfg.cors) {
        resH.set('Access-Control-Allow-Origin', '*');
        resH.set('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE, OPTIONS');
        resH.set('Access-Control-Allow-Headers', '*');
      }

      /* ===== å†™ç¼“å­˜ ===== */
      if ((isImage || isPing) && res.ok) {
        const ttl = isImage ? IMAGE_TTL : PING_TTL;
        resH.set('Cache-Control', `public, max-age=${ttl}`);

        const cachedRes = new Response(res.body, {
          status: res.status,
          headers: resH
        });

        ctx.waitUntil(cache.put(cacheKey, cachedRes.clone()));
        return cachedRes;
      }

      return new Response(res.body, {
        status: res.status,
        headers: resH
      });

    } catch (err) {
      return new Response(err.message || 'Upstream fetch error', { status: 502 });
    }
  }
};
